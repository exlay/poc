#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <string.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <dlfcn.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <error.h>
#include <dlfcn.h>
#include <rpc/rpc.h>
#include <linux/if.h>
#include <sys/ioctl.h>
#include <rpc/pmap_clnt.h>

#include "exlay.h"
#include "protocol.h"
#include "daemon.h"
#include "exlay_rpc.h" /* automatically generated by rpcgen */

#define LIBPREFIX "/home/vagrant/work/exlay/poc/protocols/lib/lib"
#define LIBSUFFFIX ".so"

extern void exlayprog_1(struct svc_req *rqstp, register SVCXPRT *transp);
static struct sockaddr_ll daem_addr_ll;
static int daem_sock;
static int prot_ctr = 0;
static int list_len = 0;
static unsigned char exsock = 0;

struct proto_info prinfo_head;
struct binding_tree root;


struct exlay_ep ep_head = {
	.fp = &ep_head,
	.bp = &ep_head,
};

static int bind_cmp(uint8_t *b1, uint8_t *b2, uint32_t bsize)
{
	int result = 0;
	uint32_t i;
	for (i = 0; i < bsize; i++) {
		if (b1[i] != b2[i]) {
			/* b1 and d2 are different */
			result = 1;
			break;
		}
	}
	return result;
}

static struct binding_tree *add_protocol_to(
		struct exlay_layer *lyr,
		struct binding_tree *lyr_root)
{
	struct binding_tree *prt;
	/* guaranteed that prt_root is not NULL */
	
	prt = malloc(sizeof(struct binding_tree));
	memset(prt, 0, sizeof(struct binding_tree));
	prt->protob = lyr->protob;
	prt->layer = lyr->layer;
	prt->lower = lyr_root->lower;
	prt->fp = lyr_root->fp;
	lyr_root->fp = prt;
	return prt;
}

static struct binding_tree *find_protocol_in(
		struct exlay_layer *lyr,
		struct binding_tree *lyr_root)
{
	struct binding_tree *prt;
	struct binding_tree *ret = NULL;

	if (lyr_root == NULL) {
		return ret;
	}

	for (prt = lyr_root->fp; prt != NULL; prt = prt->fp) {
		if (prt->protob == lyr->protob) {
			/* found */
			ret = prt;
			break;
		}
	}
	return ret;
}
static struct binding_tree *add_binding_to(
		struct exlay_layer *lyr, 
		struct binding_tree *prt_root)
{
	struct binding_tree *ent;
	ent = malloc(sizeof(struct binding_tree));
	memset(ent, 0, sizeof(struct binding_tree));
	if (ent == NULL) {
		perror("add_binding_to: malloc:");
		goto OUT;
	}
	ent->entry = lyr;
	ent->fbind = prt_root->fbind;
	ent->layer = lyr->layer;
	ent->lower = prt_root->lower;
	prt_root->fbind = ent;

OUT:
	return ent;
}

static struct binding_tree *find_binding_in(
		struct exlay_layer *ent, 
		struct binding_tree *prt_root)
{
	struct binding_tree *p;
	unsigned int bsize = ent->protob->bind_size;

	for (p = prt_root->fbind; p != NULL; p = p->fbind) {
		if (bind_cmp(p->entry->lbind, ent->lbind, bsize) == 0) {
			return p;
		}
	}
	return p;
}

static char *get_libpath(char *proto)
{
	char *ret = NULL;
	struct proto_info *p;
	for (p = prinfo_head.fp; p != &prinfo_head; p = p->fp) {
		if (strcmp(proto, p->name) == 0) {
			/* found */
			ret = p->path;
			break;
		}
	}
	return ret;
}

static int reflect_to_binding_tree(struct exlay_ep *exep)
{
	int i;
	int result = 0;
	struct exlay_layer *u_lyr; /* point to the layer defined by the user 
						  *	from the buttom to the top */

	struct binding_tree *bt; /* point to exlay binding tree structure
							  *	from the root to the leaf */
	struct binding_tree *prt;
							  
	/* 0. n=1 から初めて u_lyr が定義されたスタックを超えたら終わる
	 * 1. 第n階層に，使用する bindig が存在するか
	 * 2. ある → そのノードの upper を取り出す → n++ して 1 へ
	 *    ない → n 階層目に新たなノードを作成して最上位まで upper で辿れるようにして終了 */
	for (i = 0, bt = &root; i < exep->nr_layers; i++) {
		u_lyr = &exep->btm[i];
		if ((prt = find_protocol_in(u_lyr, bt->upper)) == NULL) {
			/* not found, the protocol can be added. */
			if (bt->upper == NULL) {
				/* there are no upper protocols */
				struct binding_tree *lyr_root;
				lyr_root = (struct binding_tree *)malloc(sizeof(struct binding_tree));
				if (lyr_root == NULL) {
					result = CODE_NMEM;
					break;
				}
				memset(lyr_root, 0, sizeof(struct binding_tree));
				lyr_root->layer = i + 1;
				bt->upper = lyr_root;
				lyr_root->lower = bt;
			}
			prt = add_protocol_to(u_lyr, bt->upper);
			prt = add_binding_to(u_lyr, prt);
		} else if ((prt = find_binding_in(u_lyr, prt)) == NULL) {
			/* u_lyr binding is not found in the bt layer */
			prt = add_binding_to(u_lyr, prt);
		} else if (i == exep->nr_layers - 1) {
			/* all requested bindings have already exist
			 * return error value */
			result = CODE_EBIND;
		}
		bt = prt;
	}
	return result;
}
static int init_exlay(void)
{
	memset(&root, 0, sizeof(struct binding_tree));
	return 0;
}



static struct exlay_ep *get_ep_from_sock(int sock)
{
	struct exlay_ep *p;
	for (p = ep_head.fp; p != &ep_head; p = p->fp) {
		if (sock == p->ep) {
			/* found */
			return p;
		}
	}
	/* if not found */
	return NULL;
}

static void init_stack(struct exlay_ep *ep, int nr_layers)
{
	int i;
	ep->nr_layers = nr_layers;
	for (i = 0; i < nr_layers; i++) {
		ep->btm[i].layer = i + 1;
		ep->btm[i].protob = NULL;
		ep->btm[i].lbind = NULL;
		ep->btm[i].rbind = NULL;
		ep->btm[i].upper = NULL;
	}
}








int init_daemon(char *ifname)
{
	struct ifreq if_req;
	
	if ((daem_sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0) {
		perror("socket");
		return errno;
	}

	memset(&daem_addr_ll, 0, sizeof(struct sockaddr_ll));
	strncpy(if_req.ifr_name, ifname, strlen(ifname));

	if (ioctl(daem_sock, SIOCGIFINDEX, &if_req) < 0) {
		perror("ioctl");
		close(daem_sock);
		return errno;
	}
	daem_addr_ll.sll_family = PF_PACKET;
	daem_addr_ll.sll_protocol = htons(ETH_P_ALL);
	daem_addr_ll.sll_ifindex = if_req.ifr_ifindex; 

	if (bind(daem_sock, (struct sockaddr *)&daem_addr_ll, sizeof(struct sockaddr_ll)) < 0) {
		perror("bind");
		return errno;
	}

	if (ioctl(daem_sock, SIOCGIFFLAGS, &if_req) < 0) {
		perror("ioctl");
		close(daem_sock);
		return errno;
	}
	
	if_req.ifr_flags = if_req.ifr_flags|IFF_PROMISC|IFF_UP;
	if (ioctl(daem_sock, SIOCSIFFLAGS, &if_req) < 0) {
		perror("ioctl");
		close(daem_sock);
		return errno;
	}

	prinfo_head.fp = &prinfo_head;

	return 0;
}

int main(int argc, char **argv)
{
	if (argc != 2) {
		fprintf(stderr, "usage: exlay_daemon <ifname>\n");
		return EXIT_FAILURE;
	}

	if (init_daemon(argv[1]) != 0) {
		return EXIT_FAILURE;
	}
	init_exlay();
	debug_printf("init_daemon: finish...\n");

	register SVCXPRT *transp;

	pmap_unset(EXLAYPROG, EXLAYVERS); 
	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, EXLAYPROG, EXLAYVERS, exlayprog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (EXLAYPROG, EXLAYVERS, udp).");
		exit(1);
	}

	svc_run();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	return 0;
}

/* RPC svc */

int *ex_create_stack_1_svc(unsigned int nr_layers, struct svc_req *rqstp)
{
	static int result;
	struct exlay_ep *exep;
	exep = (struct exlay_ep *)malloc(sizeof(struct exlay_ep));
	exep->nr_layers = nr_layers;
	exep->ep = ++exsock;
	exep->btm = (struct exlay_layer *)malloc(sizeof(struct exlay_layer) * nr_layers);
	exep->top = &exep->btm[nr_layers - 1];
	init_stack(exep, nr_layers);

	INSERT_TO_LIST_HEAD(&ep_head, exep);
	//return exep->sock;
	result = exep->ep;
	return &result;
}

int *ex_set_binding_1_svc(
		int exsock, 
		unsigned int lyr, 
		char *proto, 
		binding lbind, 
		unsigned int bsize, 
		int upper, 
		struct svc_req *rqstp)
{
	static int result;
	result = CODE_OK;

	struct exlay_ep *exep;
	char *buf;

	exep = get_ep_from_sock(exsock);
	if (exep == NULL) {
		/* no such exlay endpoint */
		result = CODE_NEXEP;
		goto OUT;
	}
	if (exep->nr_layers < lyr || lyr == 0) {
		/* no such layer in the endpoint */
		result = CODE_NLYR;
		goto OUT;
	}
	/* XXX if ex_set_binding is already called before, notify */

	buf = get_libpath(proto);
	if (buf == NULL) {
		/* cannot found protocol library */
		result = CODE_NPRTLIB;
		goto OUT;
	}

	/* load library of "proto" by protobj symbol */
	void *handle = dlopen(buf, RTLD_NOW|RTLD_GLOBAL);
	char *err;
	if ((err = dlerror()) != NULL) {
		fputs(err, stderr);
		putchar('\n');
		result = CODE_EDLOPEN;
		goto OUT;
	}
	/* XXX how should it specify the symbol name of protobj? */
	exep->btm[lyr-1].protob = (struct protobj *)dlsym(handle, proto);
	if ((err = dlerror()) != NULL) {
		fputs(err, stderr);
		putchar('\n');
		result = CODE_EDLSHM;
		goto OUT;
	}

	/* set requested binding */
	uint8_t size = exep->btm[lyr-1].protob->bind_size;
	if (bsize != size && size != 0) {
		/* specify different binding size between 
		 * protocol library and user definion 
		 * */
		result = CODE_EDIFFBS;
	}
	if (size != 0) {
		exep->btm[lyr-1].lbind = malloc(size);
		memcpy(exep->btm[lyr-1].lbind, lbind.binding_val, size);
	}

	uint8_t uplyr_type_s = exep->btm[lyr-1].protob->upper_type_size;
	if (upper != 0) {
		exep->btm[lyr-1].upper = malloc(uplyr_type_s);
		memcpy(exep->btm[lyr-1].upper, &upper, uplyr_type_s);
	} else {
		exep->btm[lyr-1].upper = NULL;
	}

OUT:
	return &result;

}

int *ex_bind_stack_1_svc(int exsock, struct svc_req *rqstp)
{
	static int result = 0;
	struct exlay_ep *exep;
	exep = get_ep_from_sock(exsock);
	if (exep == NULL) {
		/* no such endpoint */
		result = CODE_NEXEP;
		goto OUT;
	}
	/* reflect stack to binding_tree */
	result = reflect_to_binding_tree(exep);

OUT:
	return &result;
}
int *ex_set_remote_1_svc(
		int ep, 
		int lyr, 
		binding rb, 
		unsigned int bsize, 
		struct svc_req *rqstp)
{
	static int result = 0;

	struct exlay_ep *exep;
	exep = get_ep_from_sock(ep);
	if (exep == NULL) {
		/* no such endpoint */
		result = CODE_NEXEP;
		goto OUT;
	}
	uint8_t size = exep->btm[lyr-1].protob->bind_size;
	if (rb.binding_val == NULL) {
		/* unreachable */
		goto OUT;
	} else {
		if (exep->btm[lyr-1].rbind == NULL) {
		/* ex_set_remote is called for the first time */
			if ((exep->btm[lyr-1].rbind = malloc(size)) == NULL) {
				fprintf(stderr, "ex_set_remote: malloc: error: %d\n", errno);
				result = errno;
				goto OUT;
			}
		}
		memcpy(exep->btm[lyr-1].rbind, rb.binding_val, size);
	}

OUT:
	return &result;
}
int *ex_dial_stack_1_svc(int ep, struct svc_req *rqstp)
{
	static int result;
	return &result;
}

int *ex_listen_stack_1_svc(int ep, struct svc_req *rqstp)
{
	static int result;
	return &result;
}
int *ex_close_stack_1_svc(int ep, struct svc_req *rqstp)
{
	static int result = 0;
	struct exlay_ep *p;
	p = get_ep_from_sock(ep);
	if (p == NULL) {
		/* no such exlay endpoint */
		result = CODE_NEXEP;
		goto OUT;
	}
	REMOVE_FROM_LIST(p);
	free(p);

OUT:
	return &result;
}

char **exlay_list_1_svc(struct svc_req *rqstp)
{
	static char *result = "";
	debug_printf("cmd = list\n");
	static char is_freeable = 0;

	if (is_freeable) {
		free(result);
		result = "";
		is_freeable = 0;
	}

	if (list_len > 0) {
		char *p;
		result = malloc(list_len);
		is_freeable = 1;
		memset(result, '\0', list_len);

		struct proto_info *prt;
		for (prt = prinfo_head.fp, p = result; prt != &prinfo_head; prt = prt->fp) {
			memcpy(p, prt->name, strlen(prt->name));
			p += (strlen(prt->name));
			*p++ = '\n';
		}
		*p = '\0';
	} 
	return &result;
}

int *exlay_add_1_svc(char *proto, struct svc_req *rqstp)
{
	static int result = 0;
	debug_printf("cmd = add\n");
	if (result) {
		result = 0;
	}

	struct proto_info *prt;
	/* whether the protocol name to be added has already exist or not */
	for (prt = prinfo_head.fp; prt != &prinfo_head; prt = prt->fp) {
		if (strcmp(prt->name, proto) == 0) {
			result = CODE_DUP;
			goto OUT;
		}
	}
	struct proto_info *new_prt;
	new_prt = (struct proto_info *)malloc(sizeof(struct proto_info));
	if (new_prt == NULL) {
		result = CODE_NMEM;
		goto OUT;
	}
	new_prt->path = (char *)malloc(sizeof(char) * strlen(proto) + strlen(LIBPREFIX) + strlen(LIBSUFFFIX));
	new_prt->name = (char *)malloc(sizeof(char) * strlen(proto));
	memcpy(new_prt->name, proto, strlen(proto));
	//memcpy(new_prt->path, path, strlen(path));
	new_prt->name[strlen(proto)] = '\0';
	//new_prt->path[strlen(path)] = '\0';
	prot_ctr++;
	list_len += (strlen(proto) + 1);
	sprintf(new_prt->path, "%s%s%s", LIBPREFIX, proto, LIBSUFFFIX);

	char *err;
	dlopen(new_prt->path, RTLD_LAZY|RTLD_GLOBAL);
	if ((err = dlerror()) != NULL) {
		fputs(err, stderr);
		putchar('\n');
		result = CODE_NPRTLIB;
		goto OUT;
	}
	INSERT_TO_LIST_HEAD(&prinfo_head, new_prt);
	debug_printf("prot %s (%s) was successfully added\n", 
			new_prt->name, new_prt->path);

OUT:
	return &result;
}

int *exlay_del_1_svc(char *proto, struct svc_req *rqstp)
{
	static int result = 0;
	debug_printf("cmd = del\n");

	struct proto_info *prt;
	/* whether the protocol name to be deleted has really exist or not */
	for (prt = prinfo_head.fp; prt != &prinfo_head; prt = prt->fp) {
		if (strcmp(prt->name, proto) == 0) {
			/* found */
			break;
		}
	}

	if (prt == &prinfo_head) {
		result = CODE_NEXIST;
		goto OUT;
	}

	REMOVE_FROM_LIST(prt);
	prot_ctr--;
	list_len -= (strlen(prt->name) + 1);
	debug_printf("prot %s (%s) was successfully removed\n", 
			prt->name, prt->path);
	free(prt);

OUT:
	return &result;
}

char **exlay_info_1_svc(char *proto, struct svc_req *rqstp)
{
	static char **result;
	return result;
}

int *exlay_update_1_svc(char *proto, char *new_path, struct svc_req *rqstp)
{
	static int result = 0;
	return &result;
}
